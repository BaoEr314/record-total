<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style>
			p {
				margin: 15px 0;
			}
		</style>
	</head>
	<body>
		<div>
			<ul>
				<li>
					<h3>★★★ 当修改一个数据时，不想整个页面都被重新渲染，只想要渲染变更数据的那一部分，怎么做？</h3>
					<p>
						选择合适的框架，vue和react都使用了虚拟dom加diff运行，找出最小化的差异并更新到真实dom中，<br>
						只会改变发生变化的dom,不会渲染整个页面。并为列表中每一个节点添加唯一的key值，提高diff运算的速度。
					</p>
					<p>	让数据变为响应式的，如：vue中，当页面初始化时候，vue会遍历data对象所有的属性，<br>
						并使用defineProperty或Proxy把这些属性全部转化为getter/setter，所以属性必须在<br>
						data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。
					</p>
					<p>
						vue计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。
					</p>
					<p>
						Vue不允许在已经创建的实例上动态添加新的根级响应式属性，<br>
						可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上，<br>
						也可以使用 this.$forceUpdate() 方法，可以局部更新。<br>
						迫使Vue实例重新渲染。它仅仅影响实例本身和插入插槽的子组件，而不是所有字组件
					</p>
				</li>
				<li>
					<h3>★★★ 页面是否可以快速加载</h3>
					<p>
						图片资源的预加载，懒加载，cdn加速，雪碧图/精灵图<br>
						(雪碧图/精灵图就是将很多很多的小图标放在一张图片上,就称之为雪碧图)
					</p>
					<p>减少HTTP请求，尽可能的合并脚本，CSS，图像，在用户的浏览器上缓存文件</p>
					<p>压缩JS文件，图片，HTML文档，CSS文档等等</p>
					<p>去除不必要的空格, 注释 减少文件的总尺寸，较小的页面可以获得更快的加载速度</p>
					<p>把CSS放在顶端: css文件的加载不会阻塞dom树的解析，<br>
					把CSS文件放在网站的顶端，可以让网站尽可能同时加载其他部件，如图片和文字。</p>
					<p>把js放在底端: 在body闭合标签前插入js脚本,让这些脚本在后台加载的同时，用户先得到看似完整的页面。</p>
					<p>async异步 或 defer 推迟 加载js脚本</p>
					<p>避免重定向:无论是服务器端头重定向，js重定向，或者HTML元素重定向。<br>
					你的网站都会加载空白的页面的头， 然后再加载新的一页，用户为了获得需要的页面花费越来越多的时间</p>
				</li>
				<li>
					<h3>★★★ 怎么让滚动和动画流畅</h3>
					<p>前提：滚动和动画会频繁的引起回流与重绘，操作卡顿问题</p>
					<p>防抖（debounce）与 节流（throttle）都是为了限制函数的执行频次，<br>
					以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。</p>
					<p>window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，<br>
					用于准确控制页面的帧刷新渲染，让动画效果更加流畅。<br>
					频率是每秒 60 次，也就是 1000/60 ，触发频率大概是 16.7ms 。<br>
					（当执行复杂操作时，当它发现无法维持 60fps 的频率时，它会把频率降低到 30fps 来保持帧数的稳定。）</p>
					<p>避免在scroll 事件中修改样式属性或将样式操作从 scroll 事件中剥离</p>
					<p>滑动过程中尝试使用 pointer-events: none 禁止鼠标事件,可用来提高滚动时的帧频</p>
				</li>
				<li>
					<h3>★★★ 怎么图片优化</h3>
					<p>使用base64编码代替图片:适用于图片小于2KB，页面引用图片不多的情况</p>
					<p>合并图片sprite（雪碧图）</p>
					<p>使用canvas代替图片:需要高性能的图片或动画，使用HTML5的canvas元素绘制图片，页面渲染性能较高。</p>
					<p>响应式图片：不同终端对同一图片的需求不一样，根据终端加载不同的图片来节省不必要的流量</p>
					<p>图片压缩：在不得不加载图片的前提下，进一步提高优化效果，通过有损或无损压缩所见图片的大小</p>
					<p>更好的图片格式：webp、bpg、sharpP等新图片格式具有更好的压缩比</p>
					<p>字体图库代替图标：使用字体图库你不仅可以改变大小，而且还可以改变颜色。</p>
					<p>图片懒加载：在页面图片非常多的情况下，可以使用懒加载。</p>
					<p>按照HTTP协议设置合理的缓存：具体的缓存策略（如永久缓存+重命名）</p>
					<p>利用CDN加速</p>
				</li>
				<li>
					<h3>骨架屏+合理的loading</h3>
					<p>骨架屏 Skeleton Screen Loading 也叫加载占位图，是近年流行的加载控件，<br>
					通常表现形式是在界面上待加载区域填充灰色的占位图，与线框图的效果非常相似。
					</p>
					<p>loading 在一定程度上限制了用户的操作，而骨架屏不干扰用户的操作，弱网络环境下极大的优化了用户体验。</p>
					<p>异步加载样式表防止阻塞骨架屏的渲染</p>
					<p>当前端渲染内容替换掉骨架屏内容时，必须保证此时样式表已经加载完毕，<br>
					否则真正有意义的页面内容将出现 FOUC。</p>
				</li>
				<li>
					<h3>★★★ 长列表懒加载思路与性能优化</h3>
					<p>我们将需要渲染的内容限制在我们的给定固定容器中，给容器一个固定的高度与高度overflow:auto <br>
					</p>
					<p>为了避免用户快速的滚动，导致频繁的渲染行，<br>
					我们可以使用requestAnimationFrame来实现对渲染速率的控制，从而平滑的滚动</p>
					<p>对节点进行缓存，在滚动时遇到缓存中节点时，可直接使用。</p>
				</li>
				<li>
					<h3>★★★ 循环太多引起浏览器的卡顿如何处理</h3>
					<p>使用其他的循环代替for-in、for-of循环<br>
					  for-in需要同时遍历实例和原型链，在遍历上的消耗更多,<br>
					  for-of需要去调用Symbol.iterator函数来构建一个迭代器，自动调用next()，<br>
					  且不向next()传入任何值，在接收到done:true之后停止
					</p>
					<p>减少每次循环工作量，获取并存储数组的长度</p>
				</li>
			</ul>
		</div>
	</body>
</html>

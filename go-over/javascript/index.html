<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>基础</title>
		<style type="text/css">
			p {
				margin: 10px 0;
				line-height: 30px;
			}
		</style>
	</head>
	<body>
		<div>
			<ul>
				<li>
					<h3>★★js内置类型有哪些</h3>
					<p>字符串:string</p>
					<p>数字:number</p>
					<p>布尔:boolean</p>
					<p>未定义:undefined</p>
					<p>空类型:null</p>
					<p>符号:symbol(es6新增)</p>
					<p>对象:object</p>
					<p>注:除了对象之外,其他为基本类型.</p>
				</li>
				<li>
					<h3>★★★类型转换</h3>
					<p>toString:转化为字符串，不可以转null和underfined</p>
					<p>Number:转换为数字，字符串中有一个不是数值的字符，返回NaN</p>
					<p>parseInt:转换为数字，第一个字符不是数字或者符号就返回NaN</p>
					<p>String:转化为字符串</p>
					<p>Boolean():转化为布尔值</p>
				</li>
				<li>
					<h3> ★★★★ JavaScript 的作用域的理解。什么是作用域链</h3>
					<p>局部作用域:只能在函数内部访问它们</p>
					<p>全局作用域:网页的所有脚本和函数都能够访问它</p>
					<p>作用域链:</p>
					<p>当查找变量的时候，会先从当前上下文的变量对象中查找，<br>
						如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，<br>
						一直找到全局上下文的变量对象，也就是全局对象。<br>
						这样由多个执行上下文的变量对象构成的链表就叫做作用域链
					</p>
				</li>
				<li>
					<h3>★★★对闭包的看法，为什么要用闭包?说一下闭包的原理以及应用场景?闭包的 this 指向问题?</h3>
					<ul>
						<li>
							<h3>闭包的作用:</h3>
							<p>在外部访问函数内部的变量</p>
							<p>让函数内的局部变量可以一直保存下去</p>
							<p>模块化私有属性和公共属性</p>
						</li>
						<li>
							<h3>闭包的缺点：</h3>
							<p>占用内层空间 大量使用闭包会造成 栈溢出</p>
						</li>
					</ul>
				</li>
				<li>
					<h3>★★★如何确定 this 指向? 改变 this 指向的方式有哪些</h3>
					<p>1、全局上下文（函数外）</p>
					<p>2、函数上下文（函数内）</p>
					<h3>改变this指向的方法?</h3>
					<p>1. new关键字改变this指向</p>
					<p>2.apply、call、bind</p>
					<h3>介绍箭头函数的 this</h3>
					<p>由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值，
						<br> 作为自己的this值
					</p>
					<p>1. 所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。</p>
					<p>2.考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略</p>
					<p>注：作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>
				</li>
				<li>
					<h3>★★★ ES5/ES6 的继承除写法以外还有什么区别?</h3>
					<p>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加 到 this 上(Parent.apply(this))</p>
					<p>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this(所以必 须先调用父类的super()方法)，然后再用子类的构造函数修改 this。</p>
					<p>ES5 的继承时通过原型或构造函数机制来实现。</p>
					<p>ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关 键字实现继承。<br>
						子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。
						<br>注意 super 关键字指代父类的实例，即父类的 this 对象。<br>
						注意:在子类构造函数中，调用 super 后，才可使用 this关键字，否则报错
					</p>
					<h3>通俗说法:</h3>
					<p>1.class 声明会提升，但不会初始化赋值</p>
					<p>2.class 声明内部会启用严格模式。</p>
					<p>3.class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</p>
					<p>4.class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</p>
					<p>5.必须使用 new 调用 class。</p>
					<p>6.class 内部无法重写类名。</p>
				</li>
				<li>
					<h3> ★★★★ 你对事件循环有了解吗</h3>
					<p>当JavaScript执行时，会将全局执行上下文放入执行栈中，<br>
						接下来遇到函数执行上下文时会将这个上下文也放入执行栈中，<br>
						执行完毕会出栈，当执行栈为空时，会从任务队列头部拿取一个任务，<br>
						创建上下文并放入执行栈中执行。<br>
						每当执行栈为空时总会循环的从任务队列获取任务，并创建执行上下文放入执行栈执行。<br>
						这个循环我们称之为事件循环。</p>
					<p>通俗说法:</p>
					<p> 将所有任务看成两个队列：执行队列与事件队列。</p>
					<p>执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队列之前。</p>
					<p>当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务</p>
				</li>
				<li>
					<h3>★★★★ 微任务和宏任务有什么区别</h3>
					<ul>
						<li>
							<h3>微任务（microtask）</h3>
							<p>谁发起的:JS引擎</p>
							<p>具体事件: <br>
								1. Promise <br>
								2. MutaionObserver <br>
								3. Object.observe（已废弃；Proxy 对象替代）<br>
								4. process.nextTick（Node.js）
							</p>
							<p>谁先运行:先运行</p>
							<p>会触发新一轮Tick吗:不会</p>
						</li>
						<li>
							<h3>宏任务(macrotask):</h3>
							<p>谁发起的:宿主（Node、浏览器）</p>
							<p>具体事件:<br>
								1. script (可以理解为外层同步代码)<br>
								2. setTimeout/setInterval
								3. UI rendering/UI事件
								4. postMessage，MessageChannel
								5. setImmediate，I/O（Node.js）
							</p>
							<p>谁先运行:后运行</p>
							<p>会触发新一轮Tick吗:会</p>
						</li>
					</ul>
				</li>
				<li>
					<h3>★★★★★ 浏览器和 Node 事件循环的区别</h3>
					<p>浏览器中的事件循环：<br>
						<img src="../../img/2019-01-14-002.png" alt="">
					</p>
					<p>Node中的事件循环：<br>
						V8 引擎解析 JavaScript 脚本。<br>
						解析后的代码，调用 Node API。<br>
						ibuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，<br>
						形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。<br>
						V8 引擎再将结果返回给用户。
					</p>
				</li>
				<li>
					<h3>★★★ 异步解决方案有哪些</h3>
					<p>1.回调函数callbackbr
						<br>缺点:回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。
					</p>
					<p>2.事件发布订阅 <br>
						缺点：消耗内存，过度使用会使代码难以维护和理解
					</p>
					<p>3.Promise: <br>
						优点：解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。<br>
						缺点：无法取消promise。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>
						当执行多个Promise时，一堆then看起来也很不友好
					</p>
					<p>4.Generator：
						<br>Generator是es6提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用yiled语句。
						<br>Generaotr函数会返回一个遍历器，可以进行遍历操作执行每个中断点yield。
						<br>举例：

						function * count() {<br>
						&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp yield 1<br>
						&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp yield 2<br>
						&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp return 3 <br>
						&nbsp &nbsp &nbsp }
						<br>var c = count()
						<br>console.log(c.next()) // { value: 1, done: false }
						<br>console.log(c.next()) // { value: 2, done: false }
						<br>console.log(c.next()) // { value: 3, done: true }
						<br>console.log(c.next()) // { value: undefined, done: true }
						<br>
					<p>优点：没有了Promise的一堆then(),异步操作更像同步操作，代码更加清晰。</p>
					<p>缺点：不能自动执行异步操作，需要写多个next()方法，需要配合使用Thunk函数和Co模块才能做到自动执行。</p>
					<p>5.async/await：
						<br>优点：内置执行器，比Generator操作更简单。async/await比*yield语义更清晰。
						<br>返回值是Promise对象，可以用then指定下一步操作。
						<br>代码更整洁。可以捕获同步和异步的错误。
					</p>
					</p>
				</li>
				<li>
					<h3>★★★ async、await 和 promise的区别 和 这两个的本质</h3>
					<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大</p>
					<p>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，
						他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。</p>
					<p>两者的区别：<br>
						Promise的出现解决了传统callback函数导致的“地域回调”问题，<br>
						但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。
						<br>async await代码看起来会简洁些，使得异步代码看起来像同步代码，
						<br>await的本质是可以提供等同于"同步效果"的等待异步返回能力的语法糖，
						只有这一句代码执行完，才会执行下一句。
					</p>
					<p>async await与Promise一样，是非阻塞的。</p>
					<p>async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。</p>
				</li>
				<li>
					<h3>★★ Array.forEach() 与 Array.map() 的区别，Array.slice() 与 Array.splice() 的区别?</h3>
					<p>forEach不支持return,对原来的数组也没有影响。但是我们可以自己通过数组的索引来修改原来的数组</p>
					<p>map支持return返回值，也不影响原数组，但是会返回一个新的数组</p>
					<p>array.slice(start,end)函数是取array数组中指定的一些元素：
						<br>根据数组下标start和end，两个参数为取值的开始和结束下标，取出的值不包括end位置的值，生成一个新数组作为返回值；
						<br>这里end可以为空，为空则取从start位置到数组结尾的元素，生成新数组。
					</p>
					<p>array.splice(start,length,insert_one......)函数则是直接在原数组进行删除、添加、替换元素的操作：</p>
					<p>start为数组删除元素的开始下标 length为从start位置开始array删除元素的个数，
						<br>后面参数为删除之后array重新插入的数据内容，插入位置为删除位置，而非数组开头或末尾，
						<br>返回值为array删除的元素组成的数组。
					</p>
				</li>
				<li>
					<h3>★★★ bind 的作用是什么？</h3>
					<p>bind()方法主要就是将函数绑定到某个对象，</p>
					<p>bind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()第一个参数的值</p>
				</li>
				<li>
					<h3>★★★ 如何判断 user 对象里有没有 a 这个属性？如何把user对象中所有的属性都输出出来？</h3>
					<p>js对象的Object.hasOwnProperty()方法
						返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。
					</p>
					<p></p>
				</li>
				<li>
					<h3>★★★ 如何避免回调地狱？</h3>
					<p>1. Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。</p>
					<p>2.ES6 co/yield方案</p>
					<p>3. ES7 async/await 方案 async/await是es7的新标准，并且在node7.0中已经得到支持<br>
						它就是 Generator 函数的语法糖，<br>
						async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。
					</p>
				</li>
				<li>
					<h3>★★★简述同步和异步的区别</h3>
					<p>同步的思想是：所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，<br>
						给用户一种卡死了的感觉,这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。
					</p>
					<p>将用户请求放入消息队列，并反馈给用户</p>
					<p>同步和异步本身是相对的: <br>
						同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情,当服务端做完了才返回到客户端。
						<br>这样的话客户端需要一直等待。用户使用起来会有不友好。
					</p>
					<p>异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情,这样节约了时间，提高了效率。</p>

				</li>
				<li>
					<h3>★★★ 谈谈垃圾回收机制方法以及内存管理</h3>
					<p>垃圾回收方式</p>
					<p>① 标记清除:工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
					<p>② 引用计数:工作原理：跟踪记录每个值被引用的次数。一旦没有引用，内存就直接释放了。</p>
				</li>
				<li>
					<h3>★★★ 开发过程中遇到内存泄漏的问题都有哪些？</h3>
					<p>1. 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。</p>
					<p>2.闭包:闭包可以维持函数内局部变量,使其得不到释放。</p>
				</li>
				<li>
					<h3>★★★ 如何判断一个对象是否为数组，函数?</h3>
					<p> instanceof,constructor,Array.isArray</p>
					<p>
						console.log(arr instanceof Array) <br>
						console.log(arr.constructor == Array); <br>
						console.log(Array.isArray(arr));
					</p>
				</li>
				<li>
					<h3>★★★ 假如A页面我定义了一个定时器，然后跳到B页面如果让A页面的定时器暂停</h3>
					<p>方法1：在beforeDestroy()等生命周期结束阶段内清除定时器：</p>
					<p>方法2：通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器.</p>
				</li>
				<li>
					<h3>★★★ CommonJS 和 RequireJS 的实现原理</h3>
					<p>commonjs是通过module.exports导出模块,用require引入一个模块，原理：闭包</p>
					<p>requirejs是通过define定义导出模块，用require引入模块。</p>
				</li>
				<li>
					<h3> ★★★ 面向对象编程与面向过程编程的区别？</h3>
					<p> 面向过程:
						<br>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;
						<br>比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
						<br>缺点：没有面向对象易维护、易复用、易扩展
					</p>
					<p>面向对象:
						<br>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
					</p>
					<p>缺点：性能比面向过程低</p>
				</li>
				<li>
					<h3>★★★ 数据类型（判断，==和===）</h3>
					<p>== 判断值是否相等； === 判断值和数据类型是否严格相等</p>
				</li>
				<li>
					<h3>★★★★ 了解 ES6 的 Proxy 吗?</h3>
					<p>Proxy，代理，是ES6新增的功能，可以理解为代理器（即由它代理某些操作）。</p>
					<p>Proxy 对象用于定义或修改某些操作的自定义行为，可以在外界对目标对象进行访问前，对外界的访问进行改写</p>
					<p>new Proxy()表示生成一个 Proxy 实例</p>
					<p>&nbsp&nbsp&nbsp&nbsp -target：目标对象</p>
					<p>&nbsp&nbsp&nbsp&nbsp -handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p>
					<p>注意：要实现拦截操作，必须是对 Proxy 实例进行操作，而不是针对目标对象 target 进行操作。</p>
				</li>
				<li>
					<h3>★★★★ 深拷贝是什么？项目哪里是用到了深拷贝?</h3>
					<p>在拷贝构造函数中假如只完成了数据成员本身的赋值则称为“浅拷贝”;
						<br>编译器提供的默认拷贝构造函数就已经可以完成这个任务。
					</p>
					<p>而假如要复制的数据除了属性值本身以外，还要复制附加在数据属性值上的额外内容，
						<br>那就要自己来写拷贝构造函数了，来完成所谓的“深拷贝”。
					</p>
				</li>
				<li>
					<h3>★★★ ES6 class 关键字原理跟 function 什么区别？</h3>
					<p> function:可以用call apply bind 的方式 来改变他的执行上下文，<br>
						但是class 却不可以,class 虽然本质上也是一个函数 但是 其内（babel）部做了一层代理 来禁止了这种行为
					</p>
					<p>关于构造器constructor
						<br>在function定义的构造函数中，其prototype.constructor属性指向构造器自身
						<br>在class定义的类中，constructor其实也相当于定义在prototype属性上
					</p>
					<p>重复定义:
						<br>function会覆盖之前定义的方法
						<br> class会报错
					</p>
					<p>原型或者类中方法的枚举:
						<br>function构造器原型方法可被Object.keys(Point.prototype)枚举到，除了constructor,
						所有原型方法属性都可用Object.getOwnPropertyNames(Point.prototype)访问到
						<br>class中定义的方法不可用Object.keys(Point.prototype)枚举到
					</p>
				</li>
				<li>
					<h3>★★★ 简述 commonJS、AMD 和 CMD</h3>
					<p>CommonJS导出模块的方法是exports，导入模块的是require，具体规范如下:
						<br>如果一个JS文件中存在exports或require，该JS文件是一个模块
						<br>模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染
						<br>如果一个模块需要暴露一些API提供给外部使用，需要通过exports导出，exports是一个空的对象，你可以为该对象添加任何需要导出的内容
						<br>如果一个模块需要导入其他模块，通过require实现，require是一个函数，传入模块的路径即可返回该模块导出的整个内容
					</p>
					<p>注】CommonJS只是一个规范，相当于告诉你按什么标准制造汽车，但是具体怎么制造还是得看生产商。因此，有了规范以后，nodejs就去实现模块化了</p>
					<p>AMD:
						<br>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出
						<br>AMD 推崇依赖前置。
					</p>
					<p>
						CMD:
						<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
						<br>CMD 推崇依赖就近
					</p>
				</li>

				<li>
					<h3>★★★★ ES6 的新特性</h3>
					<p>1. const与let</p>
					<p>2. 模板字符串</p>
					<p>3. 解构赋值</p>
					<p>4. 对象简写法</p>
					<p>5. for...of循环</p>
					<p>6. 展开运算符</p>
					<p>7. 剩余参数(可变参数)</p>
					<p>8. ES6箭头函数</p>
					<p>9. 参数默认值</p>
					<p>10.类和继承</p>
					<p>11.模块化规范</p>
				</li>
				<li>
					<h3>★★★ 跨域是什么？有哪些解决跨域的方法和方案?</h3>
					<p>域名、协议、端口皆不同</p>
					<p>1：通过服务端代理请求。</p>
					<p>2：第二种：jsonp跨域</p>
					<p>3：CORS 跨域资源共享(xhr2)</p>
					<p>4：nginx代理跨域</p>
				</li>
				<li>
					<h3>★★★ super() 是否必须执行？不执行怎么让它不报错？</h3>
					<p>在 JavaScript 中，super 指的是父类的构造函数</p>
					<p>如果想在构造函数中使用this，你必须首先调用super。 先让父类做完自己的事</p>
					<p>不执行无法使用this:
						<br>不报错的方法：1：不使用this, 2：手动修正this
					</p>
				</li>
				<li>
					<h3>★★★★ 图片懒加载怎么实现？</h3>
					<p>原理：随着滚轮滚动，底部的图片会被不断地加载，从而显示在页面上，按需加载，<br>
						当页面需要显示图片的时候才进行加载，否则不加载</p>
					<ul>
						<li>1. 页面加载完成时记录每个img标签的src值的字符串，</li>
						<li>2. 用鼠标滚轮判断图片是否出现在屏幕，如果是，则把记录的src值赋值给src属性</li>
						<li>3. 然后让image的src来发起请求，获取对应的图片放置到DOM树的这个位置上，从而实现图片的页面渲染！</li>
					</ul>
				</li>
				<li>
					<h3>★★ES6 箭头函数和普通函数有什么差异？</h3>
					<p>1. 相比普通函数更简洁的语法</p>
					<p>2. 没有this,捕获其所在上下文的 this 值，作为自己的 this 值</p>
					<p>3. 不能使用new,箭头函数作为匿名函数,是不能作为构造函数的,不能使用new</p>
					<p>4. 不绑定arguments，用rest参数...解决 <br> let test3=(...a)=>{console.log(a[1])} //22</p>
					<p>6. 箭头函数没有原型属性</p>
					<p>7. 不能简单返回对象字面量</p>
					<p>8. 箭头函数不能当做Generator函数,不能使用yield关键字</p>
					<p>9. 箭头函数不能换行</p>
				</li>
				<li>
					<h3>★★import export commonJS 对比区别</h3>
					<p>ES6模块输出的是一个引用，而commonJS模块输出的是一个值的引用</p>
					<p>在ES6模块的内部this是undefined，而commonJS的this为一个空对象</p>
				</li>
				<li>
					<h3>★★★ map、fillter、reduce 各自有什么作用？</h3>
					<p>1：map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。</p>
					<p>2：filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，
						<br>我们可以利用这个函数过滤一些不需要的元素
					</p>
					<p>3：reduce 可以将数组中的元素通过回调函数最终转换为一个值。</p>
				</li>
				<li>
					<h3>★★★★★ JS中的常见设计模式以及应用场景???????????????????</h3>
					<p>1、单例模式:
						<br>
						单例模式就是一个实例在整个网页的生命周期里只创建一次，后续再调用实例创建函数的时候，返回的仍是之前创建的实例。
					</p>
					<p>
						2、策略模式
						<br>策略模式是指将策略（算法）封装起来，策略的目的是将算法和使用分离开。
					</p>
					<p>
						3、代理模式
						<br>代理模式很好理解，我们不能直接使用目标函数，而是通过调用代理函数来实现对目标函数的使用。
					</p>
					<p>
						4、发布订阅模式
						<br>发布订阅模式在实际应用中非常常见，例如，我们在微信App上关注了某个公众号，当该公众号有新文章发布时，就会通知我们。
						<br>发布订阅模式定义了一种一对多的依赖关系，当“一”发生变化，通知多个依赖。
					</p>
					<p>
						5、命令模式
						<br>所谓命令模式就是将下要执行的业务逻辑封装到一个函数或类中，不需要具体谁来执行该命令的
					</p>
				</li>
				<li>
					<h3>★★★ 介绍一下 ES6 中 Set, Map的区别？</h3>
					<p>Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是其他各种类型的值包括对象都可以成为Map的键</p>
					<p>Set也是一组key的集合，与Map类似。但是区别是Set不存储value，并且它的key不能重复。</p>
					<p>Set 对象类似于数组，且成员的值都是唯一的</p>
				</li>
				<li>
					<h3>★★★★ 插入几万个 dom ，如何实现页面不卡顿???????????</h3>
				</li>
			</ul>
		</div>
		<script type="text/javascript">
			// 类型转换=====================隐式转换

			// 1. 对象和布尔值比较
			//[]转换为字符串'',然后转换为数字0,true转换为数字1，所以为false
			console.log([] == true) //false 
			//2. 对象和字符串比较
			//[1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;
			console.log([1, 2, 3] == '1,2,3') //[1,2,3] == '1,2,3'
			//3. 对象和数字比较
			//对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true
			console.log([1] == 1) //true
			//4.字符串和数字比较
			console.log('1' == 1) //true
			//5. 字符串和布尔值比较
			console.log('1' == true) //true
			//6. 布尔值和数字比较
			console.log(true == 1) //true

			// 闭包==========================this指向
			var myNumber = {
				value: 1,
				add: function(i) {
					var helper = function(i) {
						console.log(this); //this指向window对象
						return this.value += i;
					}
					return helper(i);
				}
			}
			//this指向window对象（因为匿名函数的执行具有全局性，所以其this对象指向window）；
			console.log(myNumber.add(1)) //NaN
			// 修改代码实现正确功能
			var myNumber = {
				value: 1,
				add: function(i) {
					var helper = function(i) {
						console.log(this); //this指向myNumber
						return this.value += i;
					}
					return helper.apply(this, [i]);
				}
			}
			console.log(myNumber.add(1)) //2

			// 箭头函数 ====== this (settimeout和setinterval)
			// function Person() {  
			//     this.age = 0;  
			//     setTimeout(() => {
			//         console.log('箭头函数this===',this)//Person {age: 0}
			//         this.age++;
			//     }, 3000);
			// }

			// var p = new Person();

			// 普通函数
			// function Person() {
			//     this.age = 0;  
			//     setTimeout(function(){
			//         console.log(this)//window
			//         this.age++;
			//     }, 3000);
			// }

			// var p = new Person();

			// arr.slice=============================arr.splice
			const slicearr = [1, 2, 3, 4, 5]
			const slicearr1 = slicearr.slice(2, 4)
			const slicearr2 = slicearr.slice(1)
			const slicearr3 = slicearr.slice(1, -1)
			console.log('arr.slice======', slicearr, slicearr1, slicearr2, slicearr3)
			//[1, 2, 3, 4, 5], [3, 4],[2, 3, 4, 5], [2, 3, 4]
			const splicearr = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
			const splicearr1 = splicearr.splice(2, 3)
			console.log('arr.splice===', splicearr, splicearr1)
			//['a', 'b', 'f', 'g'] ['c', 'd', 'e']

			// 将 [1,2] 与 [3,[4]] 合并为 [1,2,3,[4]]
			let arr3 = [1, 2].concat([3, [4]]);
			console.log('concat=======', arr3)

			//★★ 将 1234567 转换为 1,234,567

			function fun(n) {
				return String(n).replace(/(?!^)(?=(\d{3})+\.)/g, ",")
			}
			console.log('fun(1234567)=====', fun('1234567'))

			//★★ Promise.resolve(Promise.resolve(1)).then(console.log) 
			Promise.resolve(Promise.resolve(1)).then(console.log)

			//Array.isArray()==============请写出 ES6 Array.isArray()
			if (!Array.isArray) {
				Array.isArray = function(arg) {
					console.log('手写一个Array.isArray')
					return Object.prototype.toString.call(arg) === '[object Array]';
				};
			}

			// promise=======================promise.race 

			//1. 返回一个pending状态的Promise，原Promise链会终止
			Promise.resolve().then(() => {
				console.log('ok1')
				return new Promise(() => {}) // 返回“pending”状态的Promise对象
			}).then(() => {
				// 后续的函数不会被调用
				console.log('ok2')
			}).catch(err => {
				console.log('err->', err)
			})
			// 2. Promise.race竞速方法
			let p1 = new Promise((resolve, reject) => {
				resolve('ok1')
			})

			let p2 = new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve('ok2')
				}, 10)
			})
			Promise.race([p2, p1]).then((result) => {
				console.log('promise,race===========', result) //ok1
			}).catch((error) => {
				console.log(error)
			})
			// 3. 当Promise链中抛出错误时，错误信息沿着链路向后传递，直至捕获
			Promise.resolve().then(() => {
				console.log('打印1')
				throw 'throw error1'
			}).then(() => {
				console.log('打印2')
			}, err => {
				console.log('throw error1')
			}).then(() => {
				console.log('打印3')
			})
			
			// ★★★★ ES6 中，数组监测怎么实现的（代理）
			// 通过ES6的关键字extends实现继承完成Array原型方法的重写
			class myArr extends Array {
				constructor(...args) {
					// 调用父类Array的constructor()
					super(...args)
				}
				push(...args) {
					console.log('检测到数组push啦')
					// 调用父类原型push方法
					return super.push(...args)
				}
				slice(...args) {
					console.log('检测到数组slice啦')
					return super.slice(...args)
				}
				splice(...args) {
					console.log('检测到数组splice啦')
					return super.splice(...args)
				}
			}
			let list = [1, 2, 3]
			let arr = new myArr(...list)
			arr.push(6)
			console.log('打印arr1========', arr)
			let arr1 = arr.slice(1, 3)
			console.log('打印arr2========', arr, arr1) //[1,2,3,6],[2,3]
			arr.splice(1, 3)
			console.log('打印arr3=====', arr) //[1]

			// foreach 和 map的区别
			let testarr = [1, 2, 3, 4]
			let myarr = testarr.forEach((item) => {
				return item * 2
			})
			console.log('foreach 和 map的区别=== foreach', myarr)
			let myarr1 = testarr.map((item) => item * 2)
			console.log('foreach 和 map的区别=== map', myarr1)

			//  ★★★ 0.1+0.2 等不等于 0.3?自己封装一个让他们相等的方法

			console.log(0.1 + 0.2) //0.30000000000000004
			function numbersequal(a, b) {
				return Math.abs(a - b) < Number.EPSILON;
			}
			console.log('0.1+0.2====', parseFloat((0.1 + 0.2).toFixed(10)) === 0.3)

			// js 数据类型判断 =================== toString
			console.log('js 数据类型判断 =================== toString')
			Object.prototype.toString.call(''); // [object String]
			Object.prototype.toString.call(1); // [object Number]
			Object.prototype.toString.call(true); // [object Boolean]
			Object.prototype.toString.call(Symbol()); //[object Symbol]
			Object.prototype.toString.call(undefined); // [object Undefined]
			Object.prototype.toString.call(null); // [object Null]
			Object.prototype.toString.call([]); // [object Array]
			Object.prototype.toString.call(document); // [object HTMLDocument]
			Object.prototype.toString.call(window); //[object global] window 是全局对象 global 的引用
			// padEnd=============padStart
			console.log('1'.padEnd(3, '***'))
			console.log('1'.padStart(3, '***'))
		</script>
	</body>
</html>
